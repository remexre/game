(in-package :game)

(defvar *events* nil)

(def-loop-body :events ()
  (let ((camera (when-let (scene-entry (and *renderer* (renderer-scene-entry *renderer*)))
                  (scene-camera (cdr scene-entry)))))
    (dolist (event (get-events))
      (match event
        (:close-requested (setf *continue-loop* nil))
        ((list :keyboard :r :release (list :control))
         (assets:reload-all-assets))
        ((list :resize w h)
         (gl:viewport 0 0 w h)
         (when camera
           (setf (camera-aspect-ratio camera) (coerce (/ w h) 'single-float)))
         (push event *events*))
        ((list :keyboard :w (or :press :repeat) nil) (move  1.0  0.0  0.0 camera))
        ((list :keyboard :s (or :press :repeat) nil) (move -1.0  0.0  0.0 camera))
        ((list :keyboard :a (or :press :repeat) nil) (move  0.0 -1.0  0.0 camera))
        ((list :keyboard :d (or :press :repeat) nil) (move  0.0  1.0  0.0 camera))
        ((list :keyboard :q (or :press :repeat) nil) (move  0.0  0.0 -1.0 camera))
        ((list :keyboard :e (or :press :repeat) nil) (move  0.0  0.0  1.0 camera))
        ((list :keyboard _ _ _)
         (push event *events*))
        (_ (prn t "unknown event ~s" event)))))

  (when (> (length *events*) 10)
    (prn :events "~a events queued!" (length *events*))))

(defun move (forward right up camera &key (move-speed 0.25))
  (let* ((forward (vec3-float-mul (camera-front camera) (* forward move-speed)))
         (up      (vec3-float-mul (camera-up    camera) (* up      move-speed)))
         (right   (vec3-float-mul (camera-right camera) (* right   move-speed)))
         (vecs (list forward up right)))
    (setf (camera-pos camera) (reduce #'vec3-add vecs :initial-value (camera-pos camera)))))
